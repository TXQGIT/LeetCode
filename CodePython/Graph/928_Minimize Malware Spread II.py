class Solution:
    def minMalwareSpread(self, graph, initial):
        # step1:对每个初始没有被感染的结点v, 找到可以直接令其被感染的病毒结点u.
        # step2:对每个病毒结点u, 计算可以被其唯一感染的结点数.
        # step3:在step2的结果找到结点数最多且序号最小的病毒结点.

        # 计算病毒结点u可以直接感染的结点
        def dfs(u, seen):
            for v, adj in enumerate(graph[u]):
                if adj and v not in initial and v not in seen:
                    seen.add(v)
                    dfs(v, seen)

        N = len(graph)
        clean = set(range(N)) - set(initial)
        # step1
        infected_by = {v: [] for v in clean}
        for u in initial:
            seen = set()
            dfs(u, seen)
            for v in seen:
                infected_by[v].append(u)
        # step2
        contribution = dict()
        for u in initial:
            contribution[u] = 0
        for v, neb in infected_by.items():
            if len(neb) == 1:
                contribution[neb[0]] += 1
        # step3
        ans = [-1, min(initial)]
        for u, cnt in contribution.items():
            if cnt > ans[0] or (cnt == ans[0] and u < ans[1]):
                ans = [cnt, u]
        return ans[1]

s = Solution()
graph = [[1,1,0],[1,1,1],[0,1,1]]
initial = [0,1]
print(s.minMalwareSpread(graph, initial))