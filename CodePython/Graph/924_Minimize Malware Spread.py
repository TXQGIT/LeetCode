class Solution:
    def minMalwareSpread(self, graph, initial):
        # 统计有多少个连通分量
        # 如果存在连通分量只有1个病毒结点, 移除该连通分量的病毒结点就可以减少M值
        # 如果不存在连通分量只有1个病毒结点, 那无论移除那个病毒结点都不能加上M, 此时移除索引最小的病毒

        # 以每个病毒结点开始进行dfs遍历,
        # 获取该病毒结点可以感染多少结点， 以及感染的结点中是否有原来就是病毒结点
        from collections import defaultdict
        infected_cnt = defaultdict(int)
        infected_uni = defaultdict(bool)

        def dfs(node, seen):
            for v, adj in enumerate(graph[node]):
                if adj and v not in seen:
                    seen.add(v)
                    dfs(v, seen)

        ans = min(initial)
        can_drop = -1
        initial = set(initial)
        for node in initial:
            seen = set()
            seen.add(node)
            dfs(node, seen)
            seen.remove(node)
            infected_cnt[node] = len(seen)
            # 可到达的结点中不存在病毒结点
            if len(initial & seen) == 0:
                infected_uni[node] = True
                if infected_cnt[node] > can_drop:
                    can_drop = infected_cnt[node]
                    ans = node
        return ans

s = Solution()
graph = [[1,0,0,0],[0,1,0,0],[0,0,1,1],[0,0,1,1]]
initial = [3,1]
print(s.minMalwareSpread(graph, initial))
